import { Redis } from 'ioredis';

import {
    AMBMessage,
    AMBProof,
    BountyClaimedEventDetails,
    BountyIncreasedEventDetails,
    BountyPlacedEventDetails,
    RelayState,
    RelayStateJSON,
    RelayStatus,
    MessageDeliveredEventDetails,
    KeyActionMessage,
    AMBMessageJSON,
    AMBProofJSON,
} from 'src/store/store.types';

// Monkey patch BigInt. https://github.com/GoogleChromeLabs/jsbi/issues/30#issuecomment-1006086291
(BigInt.prototype as any).toJSON = function () {
    return this.toString();
};


// Constants
const DEFAULT_REDIS_PORT = 6379;
const DEFAULT_REDIS_DB_INDEX = 4;


// ! IMPORTANT
// ! The 'RelayState' information (i.e. the bounty/message state information gathered from the 
// ! GeneralisedIncentives events) is stored just under the `messageIdentifier` that is present on
// ! the queried events. This `messageIdentifier` is generated by the GeneralisedIncentives
// ! contracts; nothing prevents a malicious contract from crafting an identifier that clashes with
// ! that of another GenerlisedIncentives contract.
// !
// ! Ideally, the 'RelayState' data storage should be also indexed by the source chain id and the 
// ! emitting contract address. However, given the limited information contained by the
// ! GeneralisedIncentives events, this is quite complex to achieve.
// !
// ! For the correct operation of this store it is very important for the `messageIdentifier`s
// ! across the GeneralisedIncentives implementations not to collide. This will always be the
// ! case when using the unaltered GeneralisedIncentives contracts, each deployed with a unique
// ! `uniqueSourceIdentifier`.


// TODO find a way to add the chainId to the RelayState index?
// TODO add the 'amb' to the RelayState index?


export class Store {

    // Redis Keys
    static readonly KEY_SEPARATOR: string = ':';
    
    static readonly RELAY_STATE_KEY_PREFIX: string = 'relay_state';
    static readonly AMB_MESSAGE_KEY_PREFIX: string = 'amb_message';
    static readonly AMB_PROOF_KEY_PREFIX: string = 'amb_proof';
    static readonly AMB_TRANSACTION_HASH_MAP_KEY_PREFIX: string = 'amb_transaction_hash_map';
    
    // Redis Channels
    static readonly ON_KEY_CHANGE_CHANNEL: string = 'on_key_change_channel';
    static readonly ON_AMB_MESSAGE_CHANNEL_PREFIX: string = 'on_amb_message_channel';
    static readonly ON_AMB_PROOF_CHANNEL_PREFIX: string = 'on_amb_proof_channel';


    readonly redis: Redis;
    readonly redisSubscriptions: Redis;
    readonly redisHost: string | undefined;
    readonly redisPort: number;
    readonly redisDBIndex: number;

    private readonly redisConnections: Redis[] = [];


    constructor() {

        this.redisHost = this.loadRedisHost();
        this.redisPort = this.loadRedisPort();
        this.redisDBIndex = this.loadRedisDBIndex();

        // Once a 'redis' connection is used for subscriptions, it may not be used to manage the
        // redis storage. Keep 2 distinct redis objects for each purpose.
        this.redis = this.getRedisConnection();
        this.redisSubscriptions = this.getRedisConnection();
    }



    // Initialization and state/redis management utils
    // ********************************************************************************************

    private loadRedisHost(): string | undefined {
        return process.env['REDIS_HOST'];
    }

    private loadRedisPort(): number {
        return process.env['REDIS_PORT']
            ? parseInt(process.env['REDIS_PORT'])
            : DEFAULT_REDIS_PORT;
    }

    private loadRedisDBIndex(): number {
        return process.env['REDIS_DB_INDEX']
            ? parseInt(process.env['REDIS_DB_INDEX'])
            : DEFAULT_REDIS_DB_INDEX;
    }

    getRedisConnection(): Redis {
        const redis = new Redis(this.redisPort, {
            db: this.redisDBIndex,
            host: this.redisHost,
        });

        this.redisConnections.push(redis);

        return redis;
    }

    async quit(): Promise<void> {
        const quitPromises = this.redisConnections.map(
            (redis) => redis.quit()
        );

        await Promise.all(quitPromises);
    }

    

    // Key management helpers
    // ********************************************************************************************

    static formatKey(...components: string[]): string {
        return components.join(Store.KEY_SEPARATOR);
    }

    async get(key: string) {
        return this.redis.get(key);
    }

    async set(key: string, value: string) {
        await this.redis.set(key, value);
        await this.postMessage<KeyActionMessage>(
            Store.ON_KEY_CHANGE_CHANNEL,
            { key, action: 'set' }
        );
    }

    async del(key: string) {
        await this.redis.del(key);
        await this.postMessage<KeyActionMessage>(
            Store.ON_KEY_CHANGE_CHANNEL,
            { key, action: 'del' }
        );
    }
    


    // Channel helpers
    // ********************************************************************************************

    static getChannel(...components: string[]): string {
        return components.join(Store.KEY_SEPARATOR);
    }

    async postMessage<T = any>(
        channel: string,
        payload: T,
    ) {
        return this.redis.publish(
            channel,
            JSON.stringify(payload),
        );
    }

    async on<T>(
        channel: string,
        callback: (payload: T) => void,
    ) {
        await this.redisSubscriptions.subscribe(channel);

        this.redisSubscriptions.on('message', (callbackChannel, callbackMessage) => {
            if (callbackChannel === channel) {
                callback(JSON.parse(callbackMessage));
            }
        });
    }

    async onPattern<T>(
        pattern: string,
        callback: (payload: T) => void,
    ) {
        await this.redisSubscriptions.psubscribe(pattern);

        this.redisSubscriptions.on('pmessage', (callbackPattern, _, callbackMessage) => {
            if (callbackPattern === pattern) {
                callback(JSON.parse(callbackMessage));
            }
        });
    }



    // Relay state utils
    // ********************************************************************************************

    static getRelayStateKey(messageIdentifier: string): string {
        return Store.formatKey(
            Store.RELAY_STATE_KEY_PREFIX,
            messageIdentifier.toLowerCase(),
        );
    }


    async getRelayStateByKey(key: string): Promise<RelayState | null> {

        const data = await this.redis.get(key);

        const rawState = data != null
            ? JSON.parse(data)
            : null;

        if (rawState == null) {
            return null;
        }

        // Recover format of types lost on JSON.stringify (bigints).
        return {
            ...rawState,

            bountyPlacedEvent: rawState.bountyPlacedEvent != undefined
                ? {
                    ...rawState.bountyPlacedEvent,
                    maxGasDelivery: BigInt(rawState.bountyPlacedEvent.maxGasDelivery),
                    maxGasAck: BigInt(rawState.bountyPlacedEvent.maxGasAck),
                    priceOfDeliveryGas: BigInt(rawState.bountyPlacedEvent.priceOfDeliveryGas),
                    priceOfAckGas: BigInt(rawState.bountyPlacedEvent.priceOfAckGas),
                    targetDelta: BigInt(rawState.bountyPlacedEvent.targetDelta),
                }
                : undefined,

            bountyIncreasedEvent: rawState.bountyIncreasedEvent != undefined
                ? {
                    ...rawState.bountyIncreasedEvent,
                    newDeliveryGasPrice: BigInt(rawState.bountyIncreasedEvent.newDeliveryGasPrice),
                    newAckGasPrice: BigInt(rawState.bountyIncreasedEvent.newAckGasPrice),
                }
                : undefined,

            deliveryGasCost: rawState.deliveryGasCost != undefined
                ? BigInt(rawState.deliveryGasCost)
                : undefined,
        };
    }

    async getRelayState(messageIdentifier: string): Promise<RelayState | null> {
        const key = Store.getRelayStateKey(messageIdentifier);
        return this.getRelayStateByKey(key);
    }


    // Update the saved RelayState using the existing and incoming state information.
    private async updateRelayState(incomingState: RelayState): Promise<void> {

        const key = Store.getRelayStateKey(incomingState.messageIdentifier);

        const data = await this.redis.get(key);
        const currentState: RelayStateJSON | null = data != null
            ? JSON.parse(data)
            : null;

        const overridingState = currentState != null;
        const newState = overridingState ? currentState : incomingState;

        if (overridingState) {
            newState.bountyPlacedEvent = incomingState.bountyPlacedEvent
                ?? currentState.bountyPlacedEvent;
            newState.messageDeliveredEvent = incomingState.messageDeliveredEvent
                ?? currentState.messageDeliveredEvent;
            newState.bountyClaimedEvent = incomingState.bountyClaimedEvent
                ?? currentState.bountyClaimedEvent;

            // Only override the 'BountyIncreased' event data if the new prices are higher than the
            // currently registered ones (events may not be processed in order).
            if (currentState.bountyIncreasedEvent && incomingState.bountyIncreasedEvent) {
                const currentIncreaseEvent = currentState.bountyIncreasedEvent;
                const incomingIncreaseEvent = incomingState.bountyIncreasedEvent;

                // NOTE: if either field increases, it is guaranteed that the other field will not
                // have decreased.
                if (
                    incomingIncreaseEvent.newDeliveryGasPrice > BigInt(currentIncreaseEvent.newDeliveryGasPrice)
                    || incomingIncreaseEvent.newAckGasPrice > BigInt(currentIncreaseEvent.newAckGasPrice)
                ) {
                    newState.bountyIncreasedEvent = incomingState.bountyIncreasedEvent;
                } else {
                    newState.bountyIncreasedEvent = currentState.bountyIncreasedEvent;
                }
            }
            else {
                newState.bountyIncreasedEvent = currentState.bountyIncreasedEvent
                    ?? incomingState.bountyIncreasedEvent;
            }

            newState.deliveryGasCost = incomingState.deliveryGasCost
                ?? currentState.deliveryGasCost;
        }

        if (newState.bountyClaimedEvent) {
            newState.status = RelayStatus.BountyClaimed;
        } else if (newState.messageDeliveredEvent) {
            newState.status = RelayStatus.MessageDelivered;
        } else {
            newState.status = RelayStatus.BountyPlaced;
        }

        await this.set(key, JSON.stringify(newState));
    }


    async setBountyPlaced(
        messageIdentifier: string,
        bountyPlacedEvent: BountyPlacedEventDetails,
    ) {
        const relayState: RelayState = {
            status: RelayStatus.BountyPlaced,
            messageIdentifier,
            bountyPlacedEvent,
        };

        await this.updateRelayState(relayState);
    }

    async setMessageDelivered(
        messageIdentifier: string,
        messageDeliveredEvent: MessageDeliveredEventDetails,
    ) {
        const relayState: RelayState = {
            status: RelayStatus.MessageDelivered,
            messageIdentifier,
            messageDeliveredEvent,
        };

        await this.updateRelayState(relayState);
    }

    async setBountyClaimed(
        messageIdentifier: string,
        bountyClaimedEvent: BountyClaimedEventDetails,
    ) {
        const relayState: RelayState = {
            status: RelayStatus.MessageDelivered,
            messageIdentifier,
            bountyClaimedEvent,
        };

        await this.updateRelayState(relayState);
    }

    async setBountyIncreased(
        messageIdentifier: string,
        bountyIncreasedEvent: BountyIncreasedEventDetails,
    ) {
        const relayState: RelayState = {
            status: RelayStatus.MessageDelivered,
            messageIdentifier,
            bountyIncreasedEvent,
        };

        await this.updateRelayState(relayState);
    }

    async setDeliveryCost(
        messageIdentifier: string,
        deliveryGasCost: bigint,
    ): Promise<void> {
        const relayState: RelayState = {
            status: RelayStatus.MessageDelivered,
            messageIdentifier,
            deliveryGasCost,
        };

        await this.updateRelayState(relayState);
    }



    // AMB data utils
    // ********************************************************************************************

    // ! NOTE: AMB messages are stored under the source chain id, whereas AMB proofs are stored
    // ! under the destination chain id.

    // ! Filter by `chainId` to prevent message deliveries/acks from overwriting each other.
    static getAMBMessageKey(
        chainId: string,
        messageIdentifier: string
    ): string {
        return Store.formatKey(
            Store.AMB_MESSAGE_KEY_PREFIX,
            chainId.toLowerCase(),
            messageIdentifier.toLowerCase(),
        );
    }

    // ! Filter by `chainId` to prevent message deliveries/acks from overwriting each other.
    static getAMBProofKey(
        chainId: string,
        messageIdentifier: string
    ): string {
        return Store.formatKey(
            Store.AMB_PROOF_KEY_PREFIX,
            chainId.toLowerCase(),
            messageIdentifier.toLowerCase(),
        );
    }

    // Key to be used to store any additional information required by the AMB-specific collector.
    static getAdditionalAMBDataKey(
        amb: string,
        key: string
    ): string {
        return Store.formatKey(
            Store.AMB_PROOF_KEY_PREFIX,
            amb,
            key,
        );
    }

    static getAMBMessagesByTransactionHashKey(
        chainId: string,
        txHash: string,
    ): string {
        return Store.formatKey(
            Store.AMB_TRANSACTION_HASH_MAP_KEY_PREFIX,
            chainId.toLowerCase(),
            txHash.toLowerCase(),
        );
    }



    static getOnAMBMessageChannel(
        chainId: string,
    ): string {
        return Store.getChannel(
            Store.ON_AMB_MESSAGE_CHANNEL_PREFIX,
            chainId.toLowerCase(),
        );
    }

    static getOnAMBProofChannel(
        chainId: string,
    ): string {
        return Store.getChannel(
            Store.ON_AMB_PROOF_CHANNEL_PREFIX,
            chainId.toLowerCase(),
        );
    }



    async getAMBMessage(
        chainId: string,
        messageIdentifier: string
    ): Promise<AMBMessage | null> {
        const key = Store.getAMBMessageKey(
            chainId,
            messageIdentifier,
        );

        const data = await this.redis.get(key);

        const parsedData: AMBMessageJSON | null = data != null
            ? JSON.parse(data)
            : null;

        return parsedData;
    }

    async getAMBProof(
        chainId: string,
        messageIdentifier: string,
    ): Promise<AMBProof | null> {
        const key = Store.getAMBProofKey(
            chainId,
            messageIdentifier,
        );

        const data = await this.redis.get(key);

        const parsedData: AMBProofJSON | null = data != null
            ? JSON.parse(data)
            : null;

        return parsedData;
    }

    async getAMBMessagesByTransactionHash(
        chainId: string,
        transactionHash: string,
    ): Promise<AMBMessage[]> {
        const key = Store.getAMBMessagesByTransactionHashKey(
            chainId,
            transactionHash,
        );
        const messageIdentifiers: string[] = await this.redis.lrange(key, 0, -1);

        const ambMessagesPromise: Promise<AMBMessage | null>[] = [];
        for (const messageId of messageIdentifiers) {
            ambMessagesPromise.push(this.getAMBMessage(chainId, messageId));
        }

        return (await Promise.all(ambMessagesPromise)).filter(
            (amb): amb is AMBMessage => amb != undefined,
        );
    }


    async setAMBMessage(
        chainId: string,
        ambMessage: AMBMessage,
    ): Promise<void> {

        const key = Store.getAMBMessageKey(
            chainId,
            ambMessage.messageIdentifier,
        );

        await this.set(key, JSON.stringify(ambMessage));

        await this.setAMBMessageTransactionHash(
            ambMessage.fromChainId,
            ambMessage.messageIdentifier,
            ambMessage.transactionHash,
        );

        const channel = Store.getOnAMBMessageChannel(
            chainId
        );
        await this.postMessage(channel, ambMessage);
    }

    async setAMBMessagePriority(
        chainId: string,
        messageIdentifier: string,
        priority: boolean
    ): Promise<void> {
        const key = Store.getAMBMessageKey(
            chainId,
            messageIdentifier
        );

        const data = await this.redis.get(key);

        if (data == null) {
            throw new Error(
                `Unable to set AMB priority: AMB message not found (message identifier: ${messageIdentifier})`
            );
        }

        const amb: AMBMessageJSON = JSON.parse(data);
        amb.priority = priority;

        await this.set(key, JSON.stringify(amb));
    }

    async setAMBMessageTransactionHash(
        chainId: string,
        messageIdentifier: string,
        transactionHash: string,
    ): Promise<void> {
        const key = Store.getAMBMessagesByTransactionHashKey(
            chainId,
            transactionHash,
        );

        await this.redis.rpush(key, messageIdentifier);
    }

    async setAMBProof(chainId: string, ambProof: AMBProof) {
        const key = Store.getAMBProofKey(
            chainId,
            ambProof.messageIdentifier
        );

        const currentProof = await this.get(key);
        if (currentProof != undefined) {
            //TODO log
            // Do not allow proofs to be set multiple times (prevent submitting the same relay more than once).
            return;
        }

        await this.set(key, JSON.stringify(ambProof));

        const channel = Store.getOnAMBProofChannel(
            chainId
        );
        await this.postMessage(channel, ambProof);
    }

    async setAdditionalAMBData<T>(amb: string, key: string, data: T): Promise<void> {
        const fullKey = Store.getAdditionalAMBDataKey(
            amb,
            key
        );
        await this.set(fullKey, JSON.stringify(data));
    }

    async getAdditionalAMBData<T>(amb: string, key: string): Promise<T | null> {
        const fullKey = Store.getAdditionalAMBDataKey(
            amb,
            key
        );
        const rawData = await this.get(fullKey);

        return rawData != null
            ? JSON.parse(rawData)
            : null;
    }

}
